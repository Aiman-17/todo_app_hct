# Data Model: Phase II Database Schema

**Feature**: 002-fullstack-web-auth
**Date**: 2025-12-30
**Database**: Neon Serverless PostgreSQL
**ORM**: SQLModel (MANDATORY)

## Overview

Phase II introduces two primary tables: **Users** (managed by Better Auth) and **Tasks** (extends Phase I model with user isolation). All queries MUST filter by `user_id` to enforce data isolation.

---

## 1. Users Table

### Schema Definition

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Unique user identifier (generated by PostgreSQL) |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL, INDEXED | User email address (used for login) |
| `name` | VARCHAR(255) | NOT NULL | User display name |
| `password_hash` | VARCHAR(255) | NOT NULL | bcrypt hashed password (12 salt rounds) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last update timestamp (auto-updated on change) |

### SQLModel Class Definition

```python
# backend/src/models/user.py
from sqlmodel import SQLModel, Field
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional

class User(SQLModel, table=True):
    """User model for authentication and task ownership.

    Attributes:
        id: Unique UUID identifier
        email: Unique email address (used for login)
        name: User display name
        password_hash: bcrypt hashed password
        created_at: Account creation timestamp
        updated_at: Last modification timestamp
    """
    __tablename__ = "users"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    email: str = Field(max_length=255, unique=True, index=True, nullable=False)
    name: str = Field(max_length=255, nullable=False)
    password_hash: str = Field(max_length=255, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    class Config:
        schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "email": "user@example.com",
                "name": "John Doe",
                "created_at": "2025-12-30T10:00:00Z",
                "updated_at": "2025-12-30T10:00:00Z"
            }
        }
```

### Indexes

- **Primary Index**: `id` (UUID, clustered)
- **Unique Index**: `email` (for fast login lookup and uniqueness enforcement)

### Constraints

- **Email Uniqueness**: Enforced at database level (UNIQUE constraint) and application level (Pydantic validation)
- **Password Storage**: NEVER store plaintext passwords; ALWAYS use bcrypt hashing with 12 salt rounds

---

## 2. Tasks Table

### Schema Definition

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INTEGER | PRIMARY KEY, AUTO_INCREMENT | Unique task identifier (sequential) |
| `user_id` | UUID | FOREIGN KEY (users.id), NOT NULL, INDEXED | Owner of the task (enforces user isolation) |
| `title` | VARCHAR(200) | NOT NULL | Task title (max 200 characters per spec) |
| `description` | TEXT | NULLABLE | Task description (max 2000 characters per spec) |
| `completed` | BOOLEAN | NOT NULL, DEFAULT FALSE | Completion status |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Task creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last modification timestamp |

### SQLModel Class Definition

```python
# backend/src/models/task.py
from sqlmodel import SQLModel, Field
from datetime import datetime
from uuid import UUID
from typing import Optional

class Task(SQLModel, table=True):
    """Task model representing a todo item owned by a user.

    Attributes:
        id: Unique integer identifier (auto-increment)
        user_id: UUID of the owning user (foreign key to users.id)
        title: Task title (max 200 characters)
        description: Optional task description (max 2000 characters)
        completed: Completion status (default False)
        created_at: Task creation timestamp
        updated_at: Last modification timestamp
    """
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: UUID = Field(foreign_key="users.id", nullable=False, index=True)
    title: str = Field(max_length=200, nullable=False)
    description: Optional[str] = Field(default="", max_length=2000)
    completed: bool = Field(default=False, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    class Config:
        schema_extra = {
            "example": {
                "id": 1,
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "title": "Buy groceries",
                "description": "Milk, eggs, bread",
                "completed": False,
                "created_at": "2025-12-30T10:00:00Z",
                "updated_at": "2025-12-30T10:00:00Z"
            }
        }
```

### Indexes

- **Primary Index**: `id` (integer, auto-increment)
- **Foreign Key Index**: `user_id` (UUID, references users.id)
- **Composite Index**: `(user_id, completed, created_at DESC)` for optimized task listing query

**Composite Index Rationale**:
The default sort order is "incomplete tasks first, then completed tasks, each group sorted newest first" (per spec.md FR-009). The composite index `(user_id, completed, created_at DESC)` optimizes this query:

```sql
SELECT * FROM tasks
WHERE user_id = '...'
ORDER BY completed ASC, created_at DESC;
```

This index allows PostgreSQL to:
1. Quickly filter by `user_id` (user isolation)
2. Group by `completed` (incomplete first)
3. Sort by `created_at DESC` within each group (newest first)

### Constraints

- **Foreign Key**: `user_id` MUST reference a valid `users.id` (cascade delete optional in future phases)
- **Title Length**: Max 200 characters (enforced by SQLModel Field and database VARCHAR(200))
- **Description Length**: Max 2000 characters (enforced by SQLModel Field and database TEXT with CHECK constraint)
- **User Isolation**: ALL queries MUST include `WHERE user_id = <authenticated_user_id>`

---

## 3. Relationships

### User → Tasks (One-to-Many)

- One User can have many Tasks
- Each Task belongs to exactly one User
- Relationship enforced by `user_id` foreign key

**SQLModel Relationship (Optional for ORM convenience)**:
```python
# backend/src/models/user.py
from typing import List
from sqlmodel import Relationship

class User(SQLModel, table=True):
    # ... existing fields ...
    tasks: List["Task"] = Relationship(back_populates="owner")

# backend/src/models/task.py
class Task(SQLModel, table=True):
    # ... existing fields ...
    owner: User = Relationship(back_populates="tasks")
```

**Note**: Relationships are OPTIONAL in SQLModel. We can query without them using manual joins:

```python
# Get all tasks for a user (without relationship)
from sqlmodel import select

statement = select(Task).where(Task.user_id == user_id)
tasks = session.exec(statement).all()
```

---

## 4. Data Migration Strategy

### Initial Setup (Phase II)
Since this is the first database-backed phase, we'll create tables on application startup:

```python
# backend/src/database.py
from sqlmodel import SQLModel, create_engine

def create_db_and_tables():
    """Create all tables if they don't exist."""
    SQLModel.metadata.create_all(engine)

# backend/src/main.py
@app.on_event("startup")
async def startup():
    create_db_and_tables()
```

### Future Migrations (Phase III+)
Use Alembic for schema versioning:

```bash
# Generate migration
alembic revision --autogenerate -m "Add tasks table"

# Apply migration
alembic upgrade head
```

**Phase II Decision**: Use `SQLModel.metadata.create_all()` for simplicity. Introduce Alembic in Phase III when schema changes become more complex.

---

## 5. Sample Data

### Sample User
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "alice@example.com",
  "name": "Alice Smith",
  "password_hash": "$2b$12$KIXxLhFz7xFGVwPq7Z8ZYeQ5X...",
  "created_at": "2025-12-30T10:00:00Z",
  "updated_at": "2025-12-30T10:00:00Z"
}
```

### Sample Tasks (for Alice)
```json
[
  {
    "id": 1,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "Buy groceries",
    "description": "Milk, eggs, bread",
    "completed": false,
    "created_at": "2025-12-30T10:05:00Z",
    "updated_at": "2025-12-30T10:05:00Z"
  },
  {
    "id": 2,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "Finish Phase II implementation",
    "description": "Complete all acceptance scenarios",
    "completed": false,
    "created_at": "2025-12-30T10:10:00Z",
    "updated_at": "2025-12-30T10:10:00Z"
  },
  {
    "id": 3,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "title": "Review PRs",
    "description": "",
    "completed": true,
    "created_at": "2025-12-29T15:00:00Z",
    "updated_at": "2025-12-30T09:00:00Z"
  }
]
```

**Sort Order Result** (per FR-009):
1. Task #2 (incomplete, newest)
2. Task #1 (incomplete, older)
3. Task #3 (completed)

---

## 6. Data Validation Rules

### User Model Validation
- **Email Format**: RFC 5322 compliant (validated by Pydantic `EmailStr`)
- **Password Requirements**: Min 8 chars, 1 uppercase, 1 lowercase, 1 number (validated before hashing)
- **Name**: Non-empty string, max 255 characters

### Task Model Validation
- **Title**: Non-empty string, max 200 characters (trimmed)
- **Description**: Optional string, max 2000 characters
- **Completed**: Boolean (default: False)
- **User Isolation**: `user_id` MUST match authenticated user

### Pydantic Schemas (for API validation)

```python
# backend/src/schemas/auth.py
from pydantic import BaseModel, EmailStr, validator
import re

class UserCreate(BaseModel):
    email: EmailStr
    name: str
    password: str

    @validator('name')
    def validate_name(cls, v):
        if not v.strip():
            raise ValueError("Name cannot be empty")
        if len(v) > 255:
            raise ValueError("Name too long (max 255 characters)")
        return v.strip()

    @validator('password')
    def validate_password(cls, v):
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters")
        if not re.search(r'[A-Z]', v):
            raise ValueError("Password must include an uppercase letter")
        if not re.search(r'[a-z]', v):
            raise ValueError("Password must include a lowercase letter")
        if not re.search(r'[0-9]', v):
            raise ValueError("Password must include a number")
        return v

class UserResponse(BaseModel):
    id: UUID
    email: str
    name: str
    created_at: datetime

    class Config:
        from_attributes = True  # Allow SQLModel → Pydantic conversion

# backend/src/schemas/task.py
class TaskCreate(BaseModel):
    title: str
    description: str = ""

    @validator('title')
    def validate_title(cls, v):
        if not v.strip():
            raise ValueError("Title cannot be empty")
        if len(v) > 200:
            raise ValueError("Title too long (max 200 characters)")
        return v.strip()

    @validator('description')
    def validate_description(cls, v):
        if len(v) > 2000:
            raise ValueError("Description too long (max 2000 characters)")
        return v

class TaskResponse(BaseModel):
    id: int
    title: str
    description: str
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True
```

---

## 7. Database Diagram

```
┌──────────────────────────┐
│         users            │
├──────────────────────────┤
│ id (UUID, PK)            │
│ email (VARCHAR, UNIQUE)  │◄──────┐
│ name (VARCHAR)           │       │
│ password_hash (VARCHAR)  │       │
│ created_at (TIMESTAMP)   │       │
│ updated_at (TIMESTAMP)   │       │
└──────────────────────────┘       │
                                   │
                                   │ FK (user_id)
                                   │
┌──────────────────────────────┐  │
│          tasks               │  │
├──────────────────────────────┤  │
│ id (INTEGER, PK, AUTO_INC)   │  │
│ user_id (UUID, FK, INDEXED)  ├──┘
│ title (VARCHAR(200))         │
│ description (TEXT(2000))     │
│ completed (BOOLEAN)          │
│ created_at (TIMESTAMP)       │
│ updated_at (TIMESTAMP)       │
└──────────────────────────────┘

Indexes:
  - users.email (UNIQUE)
  - tasks.user_id (FK index)
  - tasks.(user_id, completed, created_at DESC) (composite for sorting)
```

---

## 8. Critical Query Patterns

### Get User by Email (Login)
```python
from sqlmodel import select

statement = select(User).where(User.email == email)
user = session.exec(statement).first()
```

### Get All Tasks for User (with Default Sort)
```python
statement = (
    select(Task)
    .where(Task.user_id == user_id)
    .order_by(Task.completed.asc(), Task.created_at.desc())
)
tasks = session.exec(statement).all()
```

### Create Task (User Isolated)
```python
task = Task(
    user_id=user_id,  # From JWT token
    title=title,
    description=description,
    completed=False
)
session.add(task)
session.commit()
session.refresh(task)
```

### Update Task (with Authorization Check)
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(status_code=404, detail="Task not found")

task.title = new_title
task.updated_at = datetime.utcnow()
session.add(task)
session.commit()
session.refresh(task)
```

### Delete Task (with Authorization Check)
```python
statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
task = session.exec(statement).first()
if not task:
    raise HTTPException(status_code=404, detail="Task not found")

session.delete(task)
session.commit()
```

---

## Summary

- **Users Table**: UUID primary key, unique email index, bcrypt password hashing
- **Tasks Table**: Integer primary key, user_id foreign key, composite index for optimized sorting
- **User Isolation**: ALL queries filter by `user_id` from JWT token
- **Validation**: Pydantic schemas enforce field constraints (title max 200, description max 2000, password complexity)
- **ORM**: SQLModel MANDATORY, NO raw SQL allowed
- **Indexing**: Composite index `(user_id, completed, created_at DESC)` optimizes default task query
